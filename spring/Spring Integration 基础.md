# Spring Integration 基础



[toc]

## 基本概念

### 消息（Message）

消息，包括消息头和消息体。

```java
public interface Message<T> {

    T getPayload();

    MessageHeaders getHeaders();

}
```

**Pre-defined Message Headers**

| Header Name                      | Header Type                                    | Usage                                                        |
| -------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| ` MessageHeaders.ID`             | ` java.util.UUID`                              | An identifier for this message instance. Changes each time a message is mutated. |
| ` MessageHeaders. TIMESTAMP`     | ` java.lang.Long`                              | The time the message was created. Changes each time a message is mutated. |
| ` MessageHeaders. REPLY_CHANNEL` | ` java.lang.Object (String or MessageChannel)` | A channel to which a reply (if any) is sent when no explicit output channel is configured and there is no `ROUTING_SLIP` or the `ROUTING_SLIP` is exhausted. If the value is a `String`, it must represent a bean name or have been generated by a `ChannelRegistry.` |
| ` MessageHeaders. ERROR_CHANNEL` | ` java.lang.Object (String or MessageChannel)` | A channel to which errors are sent. If the value is a `String`, it must represent a bean name or have been generated by a `ChannelRegistry.` |



Spring Integration并不需要提供将Map的创建和填充传递给GenericMessage构造函数的方法，而是提供了一种更为方便的方法来构造Messages `MessageBuilder`。在`MessageBuilder`提供了用于产生两个工厂方法`Message`从一个现有实例`Message`或用有效载荷`Object`。从现有的进行构建时`Message`，其标头和有效负载`Message`将复制到new `Message`，如以下示例所示：

```java
Message<String> message1 = MessageBuilder.withPayload("test")
        .setHeader("foo", "bar")
        .build();

Message<String> message2 = MessageBuilder.fromMessage(message1).build();

assertEquals("test", message2.getPayload());
assertEquals("bar", message2.getHeaders().get("foo"));
```

如果您需要`Message`使用新的有效负载创建一个，但仍要从一个现有的头复制标头`Message`，则可以使用一种*复制*方法，如以下示例所示：

```java
Message<String> message3 = MessageBuilder.withPayload("test3")
        .copyHeaders(message1.getHeaders())
        .build();

Message<String> message4 = MessageBuilder.withPayload("test4")
        .setHeader("foo", 123)
        .copyHeadersIfAbsent(message1.getHeaders())
        .build();

assertEquals("bar", message3.getHeaders().get("foo"));
assertEquals(123, message4.getHeaders().get("foo"));
```

请注意，该`copyHeadersIfAbsent`方法不会覆盖现有值。另外，在前面的示例中，您可以看到如何使用设置任何用户定义的标头`setHeader`。最后，有一些`set`可用于预定义标头的方法以及一种用于设置任何标头的非破坏性方法（`MessageHeaders`还为预定义标头名称定义了常量）。



### 渠道（Channel）

> The message channel is the connection between multiple endpoints.  
>
> 消息通道连接端点 。
>
> the most important characteristic of any channel is that it logically decouples producers from consumers  .
>
> 通道最重要的目的是从逻辑上解耦生产者和消费者。
>
> Channels can be categorized based on two dimensions: type of handoff and type of
> delivery. The handoff can be either synchronous or asynchronous, and the delivery
> can be either point-to-point or publish-subscribe.  
>
> 通道可以从两种维度分类：手递手角度和分发角度，手递手角度可以是同步或者异步，分发角度可以是点对点或者发布订阅





### 消息端点（Message endpoints）  

> Message endpoints are the components that actually do something with the message.  
>
> 消息端点是真实对消息做处理的组件。
>
> Connections to the application or the outside world are also endpoints, and these connections take
> the form of channel adapters, messaging gateways, or service activators.  
>
> 端点也可以连接应用程序和外部系统，这些连接可以采用channel adapters, messaging gateways, or service activators的形式存在。



#### 渠道适配器（CHANNEL ADAPTER）  

> A Channel Adapter  connects an application to the messaging system.  
>
> Channel Adapter 连接应用程序到消息系统。
>
> Many different kinds of channel adapters exist, ranging from a method-invoking channel adapter to a web service channel adapter.   
>
> 渠道适配器存在很多中，包括方法调用渠道适配器，WebService渠道适配器。
>
> it’s sufficient to remember that a channel adapter is placed at the beginning
> and the end of a unidirectional message flow.  
>
> 需要记住的是，渠道适配器再消息流的最开始或者最末尾。



#### 消息网关（MESSAGING GATEWAY）  

> , a Messaging Gateway (see figure 1.7) is a connection that’s specific to bidirectional messaging. If an incoming request needs to be serviced by multiple threads but the invoker needs to remain unaware of the messaging system, an inbound gateway provides the solution.   
>
> On the outbound side, an incoming message can be used in a synchronous invocation, and the result is sent on the reply channel. For example, outbound gateways can be used for invoking web services and for synchronous request-reply interactions over JMS.  



#### 服务激活器（SERVICE ACTIVATOR）  

> A Service Activator (see figure 1.9) is a component that invokes a service based on an
> incoming message and sends an outbound message based on the return value of this
> service invocation.   
>
> In Spring Integration, the definition is constrained to local
> method calls, so you can think of a service activator as a method-invoking outbound
> gateway. The method that’s being invoked is defined on an object that’s referenced
> within the same Spring application context.  

#### 路由（ROUTER）  

> A Router (see figure 1.10) determines the
> next channel a message should be sent to
> based on the incoming message.  



#### 分离器（SPLITTER）  

> A Splitter (see figure 1.11) receives one message and splits it into multiple messages
> that are sent to its output channel. This is
> useful whenever the act of processing message content can be split into multiple steps
> and executed by different consumers at the
> same time.  

#### 聚合器（AGGREGATOR）  

> An Aggregator (figure 1.12) waits for a group of correlated messages and merges them
> together when the group is complete. The correlation of the messages typically is
> based on a correlation ID, and the completion is typically related to the size of the
> group. A splitter and an aggregator are often used in a symmetric setup, where some
> work is done in parallel after a splitter, and the aggregated result is sent back to the
> upstream gateway.  



### 实例

### spring integration jdbc

依赖：

```
<dependency>
	<groupId>org.springframework.integration</groupId>
	<artifactId>spring-integration-jdbc</artifactId>
</dependency>
```

application.properties

```properties
spring.datasource.url=jdbc:mysql://ip:3306/databasename?serverTimezone=UTC&amp;characterEncoding=utf-8&useSSL=false
spring.datasource.username=****
spring.datasource.password=****
spring.datasource.driverClassName=com.mysql.jdbc.Driver
```



jdbcInboundChannelAdapter.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:int="http://www.springframework.org/schema/integration"
       xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc"
       xmlns:jdbc="http://www.springframework.org/schema/jdbc"
       xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
		http://www.springframework.org/schema/integration/jdbc http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <int-jdbc:inbound-channel-adapter channel="jdbcInboundChannel"
                                      data-source="dataSource"
                                      query="select * from gprs_cdr gprs where status=1"
                                      update="update gprs set status=2 where id in(:id)">
        <int:poller fixed-rate="10000">
            <int:transactional transaction-manager="transactionManager"/>
        </int:poller>
    </int-jdbc:inbound-channel-adapter>

    <int:channel id="jdbcInboundChannel"/>

</beans>
```



JdbcHandler.java

```java
/**
 * @author <a href="mailto:zengxiangfei@chinamobile.com">zengxf</a>
 * @since 2020/2/17
 */
@Slf4j
public class JdbcHandler {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<LinkedCaseInsensitiveMap> handleCdr(List<LinkedCaseInsensitiveMap> gprsCdrList) throws Exception {
        int i=1;
        for(LinkedCaseInsensitiveMap map : gprsCdrList) {
            log.info(map.get("id").toString());

            SmsCdr smsCdr = new SmsCdr();
            smsCdr.setApn(map.get("apn").toString());
            smsCdr.setMsisnd(map.get("msisnd").toString());
            smsCdr.setLocalEventTimestamp(new Date());
            jdbcTemplate.update("update gprs_cdr set apn='success' where id='c0a82bd1-705b-1055-8170-5b30758d0000'");

            Object[] args = {map.get("apn"), map.get("msisnd")};

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                log.error("thread interupt!");
                throw e;
            }

            // throw runtimeException
            int i = 2/0;
        }
        return gprsCdrList;
    }

    public void handleErrorMessage(MessagingException messagingException) {
        log.error(messagingException.getFailedMessage().getPayload().toString());
        log.error("MessageException : ", messagingException.getMessage(), messagingException);

    }
}

```

事务配置（spring boot Auto config 会自动配置，这里可以手动配置多个数据源和事务管理器）

```java
/**
 * @author <a href="mailto:zengxiangfei@chinamobile.com">zengxf</a>
 * @since 2020/2/19
 */
@Configuration
@EnableTransactionManagement
public class SettleTransactionManagement {

    @Bean(name = "transactionManager")
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager transactionManagement = new DataSourceTransactionManager(dataSource);
        return transactionManagement;
    }
}

```



### Spring Integration JPA





### Spring Integration file



gateway写文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:integration="http://www.springframework.org/schema/integration"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:file="http://www.springframework.org/schema/integration/file"
       xmlns:task="http://www.springframework.org/schema/task"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration.xsd
			http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
			http://www.springframework.org/schema/integration/file http://www.springframework.org/schema/integration/file/spring-integration-file.xsd
            http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd">


	<integration:gateway id="fileWritingGateway" default-request-channel="writeToFileChannel"  service-interface="com.cmit.mvne.billing.preparation.process.gateway.FileWritingGateway"/>


	<file:outbound-channel-adapter  id="writeToFileChannel"
                                directory-expression="headers['directory']"
                                mode="REPLACE"/>
</beans>
```

FileWritingGateway.java

```java
public interface FileWritingGateway {

    File writeToFile(@Header(FileHeaders.FILENAME) String filename,
                     @Header("directory") File directory, String data);
}


@Service
@Slf4j
public class FileWritingService {

    @Autowired
    private FileWritingGateway fileWritingGateway;

    @Transactional
    public void writeFile(CdrFile cdrFile, String ratingPath) {
        // todo
        // writeToFile channel  directChannel
        File file = fileWritingGateway.writeToFile("foo.txt", new File(ratingPath, "gsm"), "foo");
    }
}
```













