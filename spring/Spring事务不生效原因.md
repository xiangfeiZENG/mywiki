# Spring 事务不生效原因

转载自：https://blog.csdn.net/f641385712/article/details/80445933



## 1、概述

事务在后端开发中无处不在，是数据一致性的最基本保证。在Spring中可以通过对方法进行事务的配置，而不是像原来通过手动写代码的方式实现事务的操作，这在很大程度上减少了开发的难度。因此我们在使用spring事务的时候，门槛变得异常的低，小学生水平就能很好的管理好事务，但是同学们或多或少都遇见过一些事务不生效的难题，为啥呢？本文就针对于此来做一些具体举例分析，尽量做到全覆盖

## 2、例子

> Spring团队建议在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。

**原因一：**是否是数据库引擎设置不对造成的。比如我们最常用的mysql，引擎MyISAM，是不支持事务操作的。需要改成InnoDB才能支持

**原因二：**入口的方法必须是public，否则事务不起作用（这一点由Spring的AOP特性决定的，理论上而言，不public也能切入，但spring可能是觉得private自己用的方法，应该自己控制，不应该用事务切进去吧）。另外private 方法, final 方法 和 static 方法不能添加事务，加了也不生效

**原因三：**Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚（至于为什么spring要这么设计：因为spring认为Checked的异常属于业务的，coder需要给出解决方案而不应该直接扔该框架）

**原因四：**@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 <tx:annotation-driven />
备注：本系列所有博文的讨论都针对于springboot而不再对spring做说明。
@EnableTransactionManagement 在springboot1.4以后可以不写。框架在初始化的时候已经默认给我们注入了两个事务管理器的Bean（JDBC的DataSourceTransactionManager和JPA的JpaTransactionManager ），其实这就包含了我们最常用的Mybatis和Hibeanate了。当然如果不是AutoConfig的而是自己自定义的，请使用该注解开启事务

**原因五：**请确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效）

**原因六：**请确保你的业务和事务入口在同一个线程里，否则事务也是不生效的，比如下面代码事务不生效：

```java
@Transactional
@Override
public void save(User user1, User user2) {
    new Thread(() -> {
          saveError(user1, user2);
          System.out.println(1 / 0);
    }).start();
}
```


**原因六：**也是我最想要去讲的一个原因：service方法中调用本类中的另一个方法，事务没有生效。这里我把当初保存的几张对比图贡献给大家参考，一目了然：

图一：事务不生效：.@Transactional的事务开启 ，或者是基于接口的 或者是基于类的代理被创建。所以在同一个类中一个无事务的方法调用另一个有事务的方法，事务是不会起作用的（这就是业界老问题：类内部方法调用事务不生效的问题原因）。

![image-20200219191638098](.\images\image-20200219191638098.png)

图二：事务生效

![image-20200219191902947](.\images\image-20200219191902947.png)

图三：事务生效

![image-20200219191941235](.\images\image-20200219191941235.png)

图四：事务生效

![image-20200219192114898](.\images\image-20200219192114898.png)

图五：事务生效（稍微解释一下，这里虽然是方法内部调用，但是事务切入了addInfo方法，所以即使内部抛出异常，也是可以生效的。当年我竟然惊讶，看来还是太年轻，哈哈）

![image-20200219192257534](.\images\image-20200219192257534.png)

图六：事务不生效（准确的说这叫没有事务）

![image-20200219195034132](.\images\image-20200219195034132.png)

图七：事务生效。这里必须说几句：这是我们解决方法内部调用事务不生效的最常用方法之一：内部维护一个注入自己的Bean，然后使用这个属性来调用方法。其实还有一种方法，那就是利用Aop上下文来获取代理对象(((TestService)AopContext.currentProxy()).create(); )，然后通过代理对象来调用。这里需要注意：Aop上下文spring默认是关闭的，需要手动开启

![image-20200219195244115](.\images\image-20200219195244115.png)

3、使用场景
事务的使用场景无需多言，但怎么正确的使用好事务却有很多学问而且有很深的学问。本文只在应用层面帮大家汇总一下事务不生效的原因，其实更有效的理解必须结合springboot的源码进行讨论。

4、最后
任何一件事情本身的复杂度是不会改变的，只是从一个地方转移到了另外一个地方。spring的事务管理就是这么一把双刃剑，它封闭了太对对开发者的实现，所以对开发者十分的友好。但如果出了问题，解决问题和理解问题的本质原因的复杂度将大幅提升。但是，作为新互联网时代，面向元数据编程肯定是一种趋势，而spring就是很好的先驱者。

