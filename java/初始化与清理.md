## 初始化与清理

“不安全”的编程方式主键成为编程代价高昂的主因之一，初始化和清理正是设计安全的两个问题。Java通过构造器保证初始化。

### 默认构造器

即无参构造器，若编写类中没有构造器，编译器会自动创建一个默认构造器，若已编写构造器，编译器将不会自动创建默认构造器。

### this关键字

为了让方法了解具体是那个对象调用方法，编译器暗自把“所操作对象的引用”作为第一个参数传递给方法。使用this关键字表示被传递的引用，**this关键字只能在方法内部使用**，表示对“调用方法的那个对象”的引用。

```java
eg;
Banana a,b;
...
a.peel(1);
b.peel(2);
编译器处理后，实际的调用变成如下：
Banana.peel(a,1);
Banana.peel(b,1);
```

可以通过在return中返回this，达到在一条语句里面对同一个对象执行多次操作。

```java
a.increment().increment();
```

#### static含义

static方法就是没有this的方法。在static方法的内部不能调用非静态方法。

### 清理：终结处理和垃圾回收

垃圾回收器只知道释放哪些经由new分配的内存，java允许类中定义一个名为finalize()的方法，工作原理如下：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用器finalize()方法（用于释放特殊内存区域，如c或c++创建的内存区域），并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。Java中的对象垃圾回收牢记以下三点：

1. 对象可以不被垃圾回收（参照第3点，可能还未回收或者非new创建的对象）。
2. 垃圾回收并不等于“析构”。
3. 垃圾回收只与内存有关。

无论是”垃圾回收“还是”终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，他是不会浪费时间去执行垃圾回收以恢复内存的。

#### 垃圾回收工作原理

“自适应的，分代的，停止-复制，标记-清扫”式垃圾回收器。

### 初始化相关

初始化总结如下：

1. 即使没有显示地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
2. 然后载入Dog.class(创建一个Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。
3. 当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。
4. 这块存储空间会被清零，这就自动的将Dog对象中的所有基本类型数据都设置成了默认值（对数字来说是0,），而引用则被设置成了null。
5. 执行所有出现于字段定义处的初始化动作。
6. 执行构造器。

`int[] a;`，编译器不允许指定数组的大小，这只是对数组的一个引用，数组创建相应的存储空间，必须写初始化表达式。

### 可变参数列表

eg：pringArray(Object ... args){...}

