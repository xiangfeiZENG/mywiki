<<<<<<< HEAD




# mysql 实战

[TOC]



## 影响数据库性能的因素

数据库需要**完整性**和**一致性**，相对不容易扩展。





![image-20191211092123224](./images/image-20191211092123224.png)

![image-20191211092301249](./images/image-20191211092301249.png)

![image-20191211092421262](./images/image-20191211092421262.png)

（最好不要在主库上进行数据备份）





QPS ：每秒处理的查量

TPS：每秒事务数

1. 超高的QPS和TPS：80%的数据库问题都是慢查询导致。

2. 大量的并发和超高的cpu使用率

   - 大量的并发：数据库连接数倍占满（max_connections,默认100)
   - 超高的cpu使用率：因cpu自由耗尽而出现宕机。

3. 磁盘io，磁盘io性能突然下降。（大促前调整维护计划）

4. 网卡流量：网卡io被占满（1000Mb/8 相当于 100MB）

   - 减少从服务器的数量
   - 进行分级缓存
   - 避免使用“select *”进行查询
   - 分离业务网络和服务器网络

5. 其他

   - 大表带来的问题（数据量超过千万行，表数据文件巨大，超过10G）

     - 慢查询：很难在一定的时间内过滤出所需要的数据
     - 建立索引需要很长时间，mysql<5.5 会锁表，>5.5引起主从延迟。
     - 修改表结构需要长时间锁表
       - 造成长时间主从延迟
       - 影响正常的数据操作

     解决大表问题

     - 分库分表（很少这么做），难点：分表主键选择，分表后跨分区数据的查询和统计。
     - 大表的历史数据归档，减少对前后断业务的影响。难点：归档时间点的选择，如何进行归档操作

   - 大事务带来的问题

     事务时数据库系统区别于其他一切文件系统的重要特性之一

      

     事务是一组具有原子性的sql语句。原子性、一致性、隔离性（未提交读、已提交读、可重复读，可串行化（很少使用））、持久性。

     

     定义：一个事务必须被视为一个不可分割的最小工作单元，整个事物中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作。

     

     事务的隔离型：隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其他事务是不可见的。


![image-20190201234408042](./images/image-20190201234408042.png)

未提交读：可看到其他事务的修改。

已提交读：大部分默认隔离级别（除了Mysql），只能看到已提交事务的修改

可重复读：MySQL默认，在事务开始后，可重复读，不管其他事务是否已提交。

可串行化：会在读取的每一行数据上都加锁，基本不用。

```
show varibles like '%iso%';

set session tx_isolation='read-commited'
```



事务的持久性（durability）

定义：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。



大事务：运行时间比较长，操作的数据比较多的事务

风险

- 锁定太多的数据，造成大量的阻塞和锁超时
- 回滚时所需时间比较长
- 执行时间长，容易造成主从延迟

怎样处理大事务：

- 避免一次处理太多的数据
- 移除不必要在事务中的SELECT操作



目前mysql不支持多cpu并发运算。



## 什么影响了Mysql性能

![image-20191211092617802](./images/image-20191211092617802.png)



那些因素影响数据库性能：

1. 硬件情况
2. 服务器操作系统，参数等
3. 数据库存储引擎
4. 数据库参数配置
5. 数据库结构设计和SQL语句



### 服务器硬件

#### CPU资源

是需要更好的cpu还是更多的cpu。

1. web项目适合更多的cpu，需要更高的并发量。
2. 使用多个cpu需要选择更好的mysql版本



MySQL不支持多CPU对同一SQL并发处理



**特别注意：**

- 不要在64位使用32位的服务器版本。（检查操作系统位数，使用32位操作系统对系统极大限制）
- 64位的CPU一定要工作在64位的系统下
- 对于并发比较高的场景CPU的数量比频率重要
- 对于CPU密集性场景和复杂SQL则频率越高越好





#### 内存大小

内存极大影响数据库性能。

- 内存并不是越多越好，当内存==磁盘，再增加没有意义
- 对性能影响有限度
- 并不能无限增加性能



根据数据库**热数据**选择内存



特别注意：

- 选择主板所能使用的最高频率的内存，内存频率越高，对性能越好。
- 内存大小对性能很重要，所以尽可能的大



#### 磁盘

##### 传统磁盘

选择因素：存储容量、传输速度、访问时间、主轴转速、物理尺寸

1. 传统磁盘，存储空间大，速度较慢。要选择转速快的。

2. raid技术，磁盘冗余队列的简称。简单来说Raid的作用就是把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余来保证数据完整性的技术。

   主要的raid级别

   - raid 0 ： 组建磁盘整列最简单的形式，简单来说就是多个读磁盘组合在一起，没有提供冗余或错误修复能力。
   - raid 1：有成为**磁盘镜像**。磁盘利用率仅有50%，成本高。数据冗余性好，读性能较好。大部分操作系统都可以通过软件实现raid 0 和raid1.
   - raid 5 ：分布式**奇偶校验磁盘阵列**。整个整列只需要一块冗余。写很慢，随机读很快，适合以读为主的业务。最好使用在从数据库服务器上。
   - raid 10 ：又称为分片的镜像。读写性能好，重建会很简单。

   ![image-20190202161815719](./images/image-20190202161815719.png)

   raid级别选择：

   ![image-20190202161906635](./images/image-20190202161906635.png)

##### 固态存储

优缺点：

- 相比于机械磁盘，固态磁盘有更好的随机读写性能

- 相比机械磁盘，固态磁盘能更好的支持并发

- 相比机械磁盘，固态磁盘更容易损坏

ssd：使用sata接口，可以替代传统磁盘而不需要任何改动。sata接口的ssd同样支持raid技术。

pci-E ssd：无法使用sata接口，需要独特的驱动和配置。价格比ssd要贵，性能比ssd好。

使用场景

- 适用于存在大量随机i/o的场景，热数据大小远大于内存。
- 适用于解决单线程负载的i/o瓶颈，比如从服务器上（单线程，易损耗）。



##### 网络存储san和nas

是两种外部文件存储设备加载到服务器上的方法。

san设备通过**光纤**连接到服务器，设备通过块接口访问，服务器可以将其当作磁盘使用。

- 适合大量顺序读写，*随机读写慢*，不如本地raid磁盘。

nas设备使用**网络连接**，通过基于文件的协议如nfs或smb来访问，通过有网络传输的延迟。

适合场景：

- 网络存储不适合于mysql数据库存放数据，有人使用网络存储来实现高可用（牺牲性能）—牺牲性能，不易维护。
- 适合数据库备份



特别注意（I/O子系统）

- PCIe -》SSD（可以使用传统接口） -〉Raid10 -》磁盘 -〉SAN 





#### 网络性能限制

延迟 带宽

- 采用高性能和高带宽的网络接口设备和交换机
- 对多个网卡进行绑定，增强可用性和带宽
- 尽可能进行网络隔离



- 网络带宽对性能的影响

- 网络质量对性能的影响



建议：

- 采用高性能和高带宽的网络接口设备和交换机
- 对多个网卡进行绑定，增强可用性和带宽
- 尽可能的进行网络隔离







### 服务器系统

- windows：大小写不敏感，linux大小写敏感，可能在windows能跑，linux下不能跑。
- FreeBSD：老版本不行
- Solaris：稳定性著称
- Linux
- CentOs



在CentOS下哪些参数对Mysql性能有影响：

《Linux性能优化大师》

- 内核相关参数（/etc/sysctl.conf)

  - 网络相关：

    ```
    // 每个端口最大监听队列长度，负载大的一般会修改
    net.core.somaxconn=65535
    net.core.netdev_max_backlog=65535
    net.ipv4.tcp_max_syn_backlog=65535
    
    
    // tcp连接处理的等待状态的时间，用于加快tcp连接回收速度
    net.ipv4.tcp_fin_timeout=10
    net.ipv4.tcp_tw_reuse=1
    net.ipv4.tcp_tw_recycle=1
    
    
    // tcp 连接接收和发送缓冲区大小的默认值和最大值，对于数据库应用应该把这几个值调整的大一点
    net.core.wmem_default=87380
    net.core.wmem_max=16777216
    net.core.rmem_default=87380
    net.core.rmem_max=16777216
    
    
    // 用于减少失效连接所占用的tcp系统资源数量，加快资源回收效率,可以适当改小些
    net.ipv4.tcp_keepalive_time=120
    net.ipv4.tcp_keepalive_intvl=30
    net.ipv4.tcp_keepalive_probes=3
    
    ```

  - 内存相关

    ```
    // linux 内核参数中最重要的参数之一，用于定义单个共享内存段的最大值
    // 注意：
    // 1. 这个参数应该设置的足够大，以便能在一个共享内存段下荣大整个的Innodb缓冲池的大小。
    // 2. 这个值的大小对于64位linux系统，可取的最大值为物理内存值-1byte，建议值为大于物理内存的一半，一般取值大于Innodb缓着冲池即可，可以取物理内存-1byte
    kernel.shmmax=4294967295
    // 这个参数当内存不足时会对性能产生比较明显的影响
    // linux系统内存交换区：在linux系统安装时都会有一个特殊的磁盘分区，称之为系统交换分区，free -m可以查看到
    // 在MySQL服务器上是否使用交换分区有一些争议：在MySQL服务所在的Linux系统上完全禁用交换分区
    // 带来的风险：
    // 1. 降低操作系统的性能
    // 2. 容易造成内存溢出，崩溃，或都被操作系统kill掉
    // 结论：在MySQL服务器上保留交换区还是很必要的，但是要控制何时使用交换分区 
    // 就是告诉Linux内核除非虚拟内存完全满了，否则不要使用交换区
    vm.swappiness=0
    ```

  - 其他配置

    ![image-20191216225731879](./images/image-20191216225731879.png)

    ![image-20191216230005937](./images/image-20191216230005937.png)

  - 磁盘性能相关

    ![image-20191216230156417](./images/image-20191216230156417.png)

    cfq：完全公平队列，适合桌面系统，会在队列中插入不必要请求，响应时间慢

    ![image-20191216230524055](./images/image-20191216230524055.png)

    ![image-20191216230549968](./images/image-20191216230549968.png)

    ![image-20191216230615470](./images/image-20191216230615470.png)

    修改方法：

    ![image-20191216230707999](./images/image-20191216230707999.png)

文件系统对性能的影响

![image-20191216231336470](./images/image-20191216231336470.png)





### MySQL体系结构

![image-20191221102058107](./images/image-20191221102058107.png)

客户端：jdbc，odbc，php等

MySQL服务层：实现与存储引擎无关的所有特性。

存储引擎层

注意：存储引擎是针对于表的而不是针对于库的（一个库中的不同表可以使用不同的存储引擎，不建议使用）



### 数据库存储引擎的选择

#### **插件式存储引擎**

MyISAM（5.58和之前版本）：不支持事务，表级锁

- MyISAM存储引擎表由MYD和MYI组成

  ![image-20191221102510682](./images/image-20191221102510682.png)

- 特性

  - 并发性与锁级别，使用的是表级锁，而不是行级锁，对读写混合并发性不好
  - 表损坏修复 ,`check table tablename`、`repair table tablename`
  - 支持的索引类型：fullText
  - MyISAM表支持数据压缩
  - 版本MySQL5.0时默认表大小为4G

- 使用场景

  - 非事务型应用
  - 只读类应用
  - 空间类应用：支持空间函数，gprs数据等。



#### InnoDB存储引擎：MySQL5.5及之后版本默认存储引擎，

- Innodb使用表空间进行，数据存储

  ![image-20191221105835345](./images/image-20191221105835345.png)

  ![image-20191221105936852](./images/image-20191221105936852.png)

  ![image-20191221110010389](./images/image-20191221110010389.png)

  ![image-20191221110049548](./images/image-20191221110049548.png)

  系统表空间和独立表空间要如何选择：

  比较

  - 系统表空间无法简单的收缩文件大小
  - 独立表空间可以通过optimize table命令收缩系统文件
  - 系统表空间会产生IO瓶颈
  - 独立表空间可以同时向多个文件刷新数据

  建议：

  - 对Innodb使用独立表空间

  ![image-20191221110657264](./images/image-20191221110657264.png)

  系统表空间还存储了什么信息：

  - Innodb数据字典信息，通过b数进行数据管理
  - undo回滚段

#### Innodb存储引擎的特性

- Innodb是一种事务性存储引擎

- 完全支持事务的ACID特性

- Redo Log 和Undo Log

  ![image-20191222225151368](./images/image-20191222225151368.png)

- Innodb支持行级锁

- 行级锁可以最大程度的支持并发

- 行级锁是由存储引擎层实现的

  什么是锁（数据库系统区别于文件系统的重要特性）：

  - 锁对主要作用是管理共享资源的并发访问
  - 锁用于实现事务的隔离性

  锁的类型

  - 共享锁（也称读锁）

  - 独占锁（也称写锁）

    ![image-20191222230057021](./images/image-20191222230057021.png)

  锁的粒度-锁的策略

  - 表级锁
  - 行级锁

  阻塞和死锁：

  - 什么是阻塞：在有些时刻，一个事务中的锁需要等待另一个锁的释放
  - 什么是死锁：是指两个或两个以上的事务在执行中相互占用了对方等待的资源而产生的一种异常。死锁系统会发现并自动处理，少量的死锁不影响系统的运行。

- Innodb状态检查

  `show engine innodb status`

  参考mysql官方手册。

- 适用场景

  - Innodb适合大多数OLTP应用



#### MySql常用存储引擎之CSV

文件系统存储特点

- 数据以文本方式存储在文件中
- .csv文件存储表内容
- .csm文件存储表的元数据如表状态和数据量
- .frm文件存储表结构信息
- 所有列必须都不能为NULL的
- 不支持索引，不支持大表，不适合在线处理
- 可以对数据文件直接编辑

适用场景

- 适合作为数据交换的中间表



#### Mysql常用存储引擎之Archive

文件系统存储特点

- 以zlib对表数据进行压缩，磁盘I/O更少
- 数据存在在ARZ为后缀的文件中，表结构存储在frm中。
- 只支持insert和select操作
- 只允许在自增ID列上加索引



适用场景

- 日志和数据采集类应用



#### MySQL常用存储引擎之Memory

文件系统存储引擎特点

- 也称HEAP存储引擎，所以数据保存在内存中
- 数据易失性，一旦mysql重启，表中数据会丢失，表结构会保留
- 只有一个frm文件

功能特点

- 支持HASH索引（等值查询快，无法进行范围查询）和BTree索引（范围查找快），默认为HASH索引。
- 所有字段都是固定长度varchar(10) = char(10)
- 不支持BLOG和TEXT等大字段
- Memory存储引擎适用表级锁
- 最大大小由max_heap_table_size参数决定，默认16M，修改后需要对表重建



容易混淆的概念：

- Memory存储引擎表
- 临时表
  - 系统临时表
    - 超过限制使用Mysam临时表
    - 未超限制使用Memory表
  - create temporary table 建立的临时表

使用场景

- 用于查找或者是映射表，例如邮编和地区的对应表（hash对于等值查找很高效）
- 用于保存数据分析中产生的中间表
- 用于换成周期性聚合数据的结果表

注意：Memory数据易丢失，所以要求数据可再生



#### MySQL常用存储引擎之Federated

特点

- 提供了访问远程MySQL服务器上表的方法
- 本地不存储数据，数据全部放到原创服务器上
- 本地需要保存表结构和原创服务器的连接信息（存在一个frm文件）

如何使用

- 很少使用，禁止，启用需要在启动时增加federated参数

   ```
  mysql://user_name[:password]@host_name[:port_num]/db_name/tbl_name
  show engines;
  在my.cnf中加入：
  federated=1
  重启mysql服务器
  ```

  ![image-20200203134159881](./images/image-20200203134159881.png)

- 可以通过复制实现该特性

使用场景

偶尔的统计分析及手工查询。



#### 如何选择存储引擎

大部分情况下，选择innodb。除非万不得已，不要混合使用存储引擎。

参考条件

- 事务
- 备份 innodb支持免费在线热备方案 mysqldump不是在线热备方案
- 奔溃恢复
- 存储引擎的特有特性



#### MySQL服务器参数介绍

MySQL获取配置路径

- 命令行参数

  `mysqld_safe --datadir=/data/sql_data`

- 配置文件

  通过以下命令获取mysql读取配置文件的顺序。

  ![image-20200314084440957](./images/image-20200314084440957.png)

Mysql配置参数作用域：

- 全局参数(可能需要重新登录才能生效)

  - set global 参数名=参数值;
  - set @@global.参数名  :=参数值;

- 会话参数

  set [session] 参数名=参数值

  set @@session.参数名:=参数值;

mysql5.7之后有部分参数支持修改全局参数后不需要重新登录就可以生效。



### 数据库参数配置（重要）

进行mysql参数配置之前，需要先找到相关配置文件：

```
[root@mvne-mysql ~]# which mysqld
/usr/sbin/mysqld

# 查看配置文件位置 mysql按以下顺序读取配置文件
[root@mvne-mysql ~]# /usr/sbin/mysqld --verbose --help | grep  -A 1 'Default options'
Default options are read from the following files in the given order:
/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf 
```



#### 内存相关参数

- 确定可以使用的内存的上限，如果32位操作系统（Mysql单进程）就只能使用3G以内内存

- 确定Mysql的每个连接使用的内存

  sort_buffer_size：在查询需要排序时，会给所有连接分配该指定内存。分配时要小心，不宜过大。

  join_buffer_size：连接缓冲，当多表查询时会分配多个

  read_buffer_size:4K倍数 有查询需要时

  read_rnd_buffer_size

- 确定需要为操作系统保留多少内存

- 如何为缓存池分配内存

  - Innodb_buffer_pool_size ：缓存索引，数据等数据，延迟写入。必须保证足够的内存。

    总内存-（每个线程所需要的内存*连接数）-系统保留内存

    （MySQL手册建议的时服务器内存的75%）

  - key_buffer_size:主要用于myisam，myisam缓存池只缓存索引，数据依赖于操作系统的缓存。Mysql的系统表还在使用myisam存储引擎，所以还是需要给key_buffer_size分配一定的空间。【

    ![image-20200314103659184](./images/image-20200314103659184.png)

    

#### I/O相关配置参数

##### InnoDB I/O相关配置

- Innodb_log_file_size 控制了单个事务日志的大小 。跟业务情况相关，如果业务非常繁忙，设置大一些有好处。大小应为记录服务器一个小时左右的事务信息。

- Innodb_log_files_in_group 控制着事务日志文件的个数

- 事务日志的总大小=Innodb_log_file_size*Innodb_log_files_in_group

- Innodb_log_buffer_size :   能够保留1秒钟的事务就足够了。 32M～128M

- Innodb_flush_log_at_trx_commit : 刷新事务日志的频繁程度

  设置为2时mysql进程奔溃不会丢失数据，但是在整个服务器宕机可能会丢失1秒数据。

  ![image-20200314145337744](./images/image-20200314145337744.png)

![image-20200314145900954](./images/image-20200314145900954.png)



##### MyISAM I/O相关配置

- delay_key_write

  ![image-20200314150146672](./images/image-20200314150146672.png)



#### 安全相关配置

- expire_logs_days 指定自动清理binlog的天数

- max_allowed_packet 控制mysql可以接收包的大小 32M 主从复制，主从这个参数要保持一致。

- skip_name_resolve 禁用DNS查找

- sys date_is_now 确定sys date()返回确定性日期，和now()结果一致。 建议增加

- read_only 禁止非super权限的用户写权限 建议在从库中启用。在给用户授权时注意，不要给予super权限。

- skip_slave_start 禁用slave自动恢复 用在从库上，阻止mysql在重启后试图自动的启动复制。

- sql_mode 设置MySQL所使用的SQL模式

  ![image-20200314162522117](./images/image-20200314162522117.png)

#### 其他常用配置参数

- sync_binlog 控制MySQL如何向磁盘刷新binlog 默认为0，表示默认由操作系统控制 主从复制的主DB来说，建议设置为1，避免由于主DB奔溃而造成cache中的日志没有同步到二进制文件中。
- tmp_table_size 和 max_heap_table_size 控制内存临时表大小（memory存储引擎）
- max_connections 控制允许的最大连接数 默认值只有100，同城情况下会设置为2000或者稍微更大些。





### 数据库结构设计和SQL语句（影响最大）

数据库设计对性能的影响

- 过分的反范式化为表建立太多的列
- 过分的范式化造成太多的表关联（最多关联61个表），关联表应控制在10个以内
- OLTP环境中使用不恰当的分区表
- 使用外键保证数据的完整性（强烈建议不要使用外键约束）



性能优化顺序

- 数据库结构设计和SQL语句
- 数据库存储引擎的选择和参数配置
- 系统选择及优化
- 硬件升级



## MySQL基准测试

测量系统的性能 判断优化是否有效

基准测试：基准测试是一种测量和评估软件性能指标的活动用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新进行基准测试以评估变化对性能的影响。

基准测试是针对系统设置的一种压力测试。

基准测试：直接、简单、易于比较、用于评估服务器的处理能力。简化了的压力测试。

压力测试：对真实的业务数据进行测试，获得真实系统所承受的压力。



### 如何进行基准测试

基准测试的目的：

- 建立MySQL服务器的性能基准线，确定当前MySQL服务器运行情况。

- 模拟比当前系统更高的负载，以找出系统扩展瓶颈

  增加数据库并发、观察QPS、TPS变化，确定并发量与性能最优关系

- 测试不同的硬件、软件和操作系统配置

- 证明新的硬件设备是否配置正确。



对整个系统进行基准测试

从系统入口进行测试（如网站Web前端、手机App前端）

优点：

- 能够测试整个系统的性能，包括Web服务器缓存、数据库等。
- 能够反映出系统中各个组件接口间的性能问题体现真实性能状况。

缺点

- 测试设计复杂，消耗时间长



单独对MySQL进行基准测试

优点：

- 测试设计简单，所需耗费时间短

缺点：

- 无法全面了解整个系统的性能基线



指标

- 单位时间内所处理的事务数（TPS）

- 单位时间内所处理的查询数（QPS）

- 响应时间

  平均响应时间、最小响应时间、最大响应时间、各个时间所占百分比

- 并发量：同时处理的查询请求的数量（并发量并不等于连接数），指的是正在工作中的并发的操作数或同时工作的数量。



### 基准测试演示实例

计划和设计基准测试

- 对整个系统还是某一组件

- 使用什么样的数据

- 准备基准测试及数据收集脚本

  CPU使用率、IO、网络流量、状态与计数器信息 等

  Get_Test_info.sh 

  ![image-20200314174531475](./images/image-20200314174531475.png)



- 运行基准测试

- 保存和分析基准测试结果

  analyze.sh

  ![image-20200314183753638](./images/image-20200314183753638.png)



基准测试容易忽略的问题：

- 使用生产环境数据时只使用了部分数据
- 在多用户场景中，只做单用户的测试 。推荐多线程并发测试。
- 在单服务器上测试分布式应用 **推荐：**使用相同的架构进行测试。
- 反复执行统一查询



### Mysql基准测试工具

ab，httploader，对系统进行整体测试。

MySQL基准测试工具之 mysqlslap，mysql服务器自带，无需安装。

特点：

- 可以模拟服务器负载，并输出相关统计信息。
- 可以指定也可以自动生成查询语句。



常用参数说明：

- `--auto-generate-sql`由系统自动生成SQL脚本进行测试
- `--auto-generate-sql-add-autoincrement`在生成的表中增加自增ID
- `--auto-generate-sql-load-type`指定测试中使用的查询类型 默认使用混合（读写删除查询更新）
- `--auto-generate-sql-write-number`指定初始化数据生成的数据量。
- `--concurrency`指定并发线程数量。
- `--engine`指定要测试表的存储引擎，可以用逗号分隔多个存储引擎。
- `--no-drop`指定不清理测试数据
- `--iterations`指定测试运行的次数。每次测试都会重新生成测试数据，指定了这个参数，就不能指定no-drop参数。
- `--number-of-queries`指定每一个线程执行的查询数量
- `--debug-info` 指定输出额外的内存及CPU统计信息
- `--number-int-cols`指定测试表中包含INT类型列的数量
- `--number-char-cols`指定测试表中包含的varchar类型的数量
- `--create-schema`指定了用于执行测试的数据库的名字
- `--query`用于指定自定义SQL的脚步
- `--only-print`并不允许测试脚本，而是把生成的脚本打印出来





## MySQL数据库结构优化

 数据库结构设计目的：

- 减少数据冗余
- 尽量避免数据维护中出现更新，插入和删除异常
  - 插入异常：如果表中某个实体随着另一个实体存在而存在
  - 更新异常：如果更改表中某个实体的单独属性时，需要对多行进行更新。
  - 删除异常：如果删除表中某一个实体会导致其他实体的消失
- 节约数据存储空间
- 提高查询效率



数据库设计的步骤

![image-20200411203619484](D:\00_reference\mywiki\database\images\image-20200411203619484.png)

![image-20200411203719199](D:\00_reference\mywiki\database\images\image-20200411203719199.png)

![image-20200411204601529](D:\00_reference\mywiki\database\images\image-20200411204601529.png)

![image-20200411204622071](D:\00_reference\mywiki\database\images\image-20200411204622071.png)



### 数据库设计范式

设计出没有数据冗余和数据维护异常的数据库结构



考虑实际的业务情况

数据库三范式

![image-20200411204850527](D:\00_reference\mywiki\database\images\image-20200411204850527.png)

![image-20200411205005696](D:\00_reference\mywiki\database\images\image-20200411205005696.png)

![image-20200411210540694](D:\00_reference\mywiki\database\images\image-20200411210540694.png)





![image-20200411214126207](D:\00_reference\mywiki\database\images\image-20200411214126207.png)



![image-20200411215015470](D:\00_reference\mywiki\database\images\image-20200411215015470.png)





不能完全按照范式化的要求进行设计

考虑以后如何使用表



### 范式化设计和反范式化设计优缺点

范式化优点：

![image-20200411215443752](D:\00_reference\mywiki\database\images\image-20200411215443752.png)



![image-20200411215602945](D:\00_reference\mywiki\database\images\image-20200411215602945.png)



反范式化优点：



![image-20200411215756818](D:\00_reference\mywiki\database\images\image-20200411215756818.png)



![image-20200411215834530](D:\00_reference\mywiki\database\images\image-20200411215834530.png)



结合使用范式化和反范式化。



### 数据库物理设计

![image-20200411220633447](D:\00_reference\mywiki\database\images\image-20200411220633447.png)



![image-20200411220917302](D:\00_reference\mywiki\database\images\image-20200411220917302.png)



### 数据类型的选择

![image-20200411221227805](D:\00_reference\mywiki\database\images\image-20200411221227805.png)



#### 如何选择正确的整数类型：

![image-20200411221401781](D:\00_reference\mywiki\database\images\image-20200411221401781.png)



#### 如何选择正确的实数类型

![image-20200411221905625](D:\00_reference\mywiki\database\images\image-20200411221905625.png)



#### 如何选择varchar和char类型

![image-20200411222421544](D:\00_reference\mywiki\database\images\image-20200411222421544.png)



- ![image-20200411222814492](D:\00_reference\mywiki\database\images\image-20200411222814492.png)

最小的符合需求长度的**真实目的**是减少加载后内存的大小。



![image-20200411222908239](D:\00_reference\mywiki\database\images\image-20200411222908239.png)





![image-20200411223051332](D:\00_reference\mywiki\database\images\image-20200411223051332.png)



![image-20200411223240203](D:\00_reference\mywiki\database\images\image-20200411223240203.png)



#### 如何存储日期数据

datetime最为通用，也是最常用的。

![image-20200411223523094](D:\00_reference\mywiki\database\images\image-20200411223523094.png)



![image-20200411223709918](D:\00_reference\mywiki\database\images\image-20200411223709918.png)



![image-20200411223756451](D:\00_reference\mywiki\database\images\image-20200411223756451.png)



date类型和time类型

date：比如存储生日

![image-20200411224418572](D:\00_reference\mywiki\database\images\image-20200411224418572.png)

![image-20200411224503383](D:\00_reference\mywiki\database\images\image-20200411224503383.png)



![image-20200411224702174](D:\00_reference\mywiki\database\images\image-20200411224702174.png)

![image-20200411224755447](D:\00_reference\mywiki\database\images\image-20200411224755447.png)



![image-20200411225005407](D:\00_reference\mywiki\database\images\image-20200411225005407.png)







## MySQL高可用架构设计

MySQL复制功能提供分担读负载

![image-20200412151338494](D:\00_reference\mywiki\database\images\image-20200412151338494.png)



通过二进制日志实现。



### 复制解决了什么问题

- 实现再不同服务器上的数据分布

  利用二进制日志增量进行

  不需要太多的带宽

  但是使用基于行的复制再进行大批量的更改时，会对带宽带来一定的压力

  特别是跨IDC环境进行复制

  应该分批进行

- 实现数据读取的负载均衡

  需要其他组件配合完成

  利用DNS轮询的方式把程序的读连接到不同的备份数据库，使用LVS，haproxy这样的代理方式。

  非共享架构，同样的数据分布在多台服务器上

- 增强了数据安全性

  利用备库的备份来减少主库负载，复制并不能代替备份，需要做备份

  方便进行数据库高可用架构的部署，避免MySQL单点失败

- 实现数据库高可用和故障切换
- 实现数据库在线升级





### 二进制日志binlog

MySQL服务层日志：

- 二进制日志：记录了所有对MySQL数据库的修改事件，包括增删改查事件和对表结构的修改事件。
- 慢查日志
- 通用日志



MySQL存储引擎日志

- innodb
  - 重做日志
  - 回滚日志



二进制日志的格式

- 基于段的格式 binlog_format=STATEMENT
  - 优点
    - 日志记录量相对较少，节约磁盘及网络I/O 
  - 缺点
    - 必须要记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同
    - 特定函数如UUID(),user()这样非确定性函数还是无法复制，可能造成MySQL复制的主备服务器数据不一致

![image-20200412153239340](D:\00_reference\mywiki\database\images\image-20200412153239340.png)



![image-20200412153332006](D:\00_reference\mywiki\database\images\image-20200412153332006.png)



mysqlbinlog log



基于行的日志格式：binlog_format=ROW

Row格式可以避免MySQL复制中出现主从不一致问题

同一SQL语句修改了10000条数据的情况下，基于段的日志格式只会记录这个sQL

语句，基于行的日志会有10000条记录分别记录每一行的数据修改。

优点：

- 使用MySQL主从复制更加安全

- 对每一行数据的修改比基于段的复制高效

  ![image-20200412154026611](D:\00_reference\mywiki\database\images\image-20200412154026611.png)

缺点：

- 记录日志量大

  binlog_row_image=[**FULL**|MINIMAL|NOBLOB]

  

mysqlbinlog -vv log





混合日志格式 binlog_format=MIXED

特点：

- 根据SQL语句由系统决定在基于段和基于行的日志格式中进行选择
- 数据量的大小由所执行的SQL语句决定



如何选择二进制日志的格式：

建议：

- binlog_format=mixed 或者**binlog_format=row,binlog_row_miage=minimal**

  

### MySQL二进制日志格式对复制的影响

![image-20200412160253907](D:\00_reference\mywiki\database\images\image-20200412160253907.png)

![image-20200417110736286](D:\00_reference\mywiki\database\images\image-20200417110736286.png)

![image-20200417110914288](D:\00_reference\mywiki\database\images\image-20200417110914288.png)



![image-20200417111141782](D:\00_reference\mywiki\database\images\image-20200417111141782.png)

![image-20200417111450427](D:\00_reference\mywiki\database\images\image-20200417111450427.png)



### MySQL复制工作方式



![image-20200417111930549](D:\00_reference\mywiki\database\images\image-20200417111930549.png)



### 配置MySQL复制

#### 基于日志点复制

基于日志点的复制配置步骤：

1. 在主DB服务器上建立复制账号

```
CREATE USER 'repl'@'IP段' identified by 'Passw0rd';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'IP段';
```

2. 配置主数据库服务器

   ```
   bin_log=mysql-bin  // 启动bin log
   server_id=100      // 可以使用set命令进行配置，修改后一定要在配置文件中修改
   
   ```

3. 配置从数据库服务器

   ```
   bin_log=mysql-bin
   server_id=101
   relay_log=mysql-relay-bin
   
   log_slave_update=on[可选]
   read_only=on[可选]
   ```

4. 初始化从服务器数据：主数据库数据备份，同步到从服务器

   ```
   mysqldump --master-data=2 --single-transaction
   msster-data：偏移量
   
   xtrabackup --slave-info  所有表都使用innodb，否则也有可能会锁表
   
   
   ```

5. 启动复制链路

   ```
   CHANGE MASTER TO MASTER_HOST='master_host_ip'
   			MASTER_USWER='repl',
   			MASTER_PASSWORD='Passw0rd',
   			MASTER_LOG_FILE='mysql_log_file_name',
   			MASTER_LOG_POS=4;
   ```

   

6. 具体操作

   ![image-20200417123653436](D:\00_reference\mywiki\database\images\image-20200417123653436.png)

   参数设置：略

   ![image-20200417123928929](D:\00_reference\mywiki\database\images\image-20200417123928929.png)

   ![image-20200417124135471](D:\00_reference\mywiki\database\images\image-20200417124135471.png)

   在从上执行：

   在备份的all.sql里面找到MASTER_LOG_FILE  和 MASTER_LOG_POS

   ![image-20200417124342859](D:\00_reference\mywiki\database\images\image-20200417124342859.png)

   ![image-20200417124420477](D:\00_reference\mywiki\database\images\image-20200417124420477.png)

   ![image-20200417124456475](D:\00_reference\mywiki\database\images\image-20200417124456475.png)

   ![image-20200417124530279](D:\00_reference\mywiki\database\images\image-20200417124530279.png)

   ![image-20200417124554691](D:\00_reference\mywiki\database\images\image-20200417124554691.png)

   在主服务器上查看：

   ![image-20200417124657654](D:\00_reference\mywiki\database\images\image-20200417124657654.png)



基于日志点复制配置步骤

优点：

- 是MySQL最早支持的复制技术，Bug相对较少
- 对SQL查询没有任何限制
- 故障处理比较容易

缺点：

- 故障转移时重新获取新主的日志点信息比较困难



#### 基于GTID复制

基于GTID的复制从**MySQL 5.6**开始支持。



![image-20200417125143502](D:\00_reference\mywiki\database\images\image-20200417125143502.png)

![image-20200417125215152](D:\00_reference\mywiki\database\images\image-20200417125215152.png)



##### 什么是GTID

GTID即全局事务ID，其保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。



GTID=source_id:transaction_id

source_id:执行事务主库的server uuid





##### 基于GTID 复制的步骤

1. 在主DB服务器上建立复制账号

   ```
   CREATE USER 'repl'@'IP段' identified by 'PassW0rd';
   GRANT REPLICATION SLAVE ON *.* TO 'repl'@'IP段';
   ```

   不能手动建立

2. 配置主数据库服务器

   ```
   bin_log=/usr/local/mysql/log/mysql-bin
   server_id=100 // 在整个复制集群是唯一的
   gtid_mode=on
   
   enforce-gitd-consiste
   1.启动该参数，以下语句不能使用create table... select，只能通过create table后再select into
   2.在事务中使用Create temporary table建立临时表使用关联更新事务表和非事务表
   
   
   log-slave-updates=on  // 5.7之后不需要该参数
   
   ```

   

3. 配置从数据库服务器

   ```
   server_id = 101
   relay_log = /usr/local/mysql/log/relay_log
   gtid_mode = on
   enforce-gtid-consistency
   
   log-slave-updates = on
   read_only = on [建议]
   master_info_repository = TABLE [建议]
   relay_log_info_repository = TABLE [建议]
   ```

   

4. 初始化从服务器数据

   ```
   mysqldump --master-data=2 --single-gransaction
   
   xtarbackup --slave-info
   记录备份时最后的事务的GTID值
   
   
   ```

   

5. 启动基于GTID的复制

   ```
   // 从服务器上
   CHANGE MASTER TO MASTER_HOST = 'master_host_ip',
   						MASTER_USER = 'repl',
   						MASTER_PASSWORD = 'pASSw0RD'
   						MASTER_AUTO_POSITION = 1
   ```



基于GTID复制的优缺点

优点：

- 可以很方便的进行故障转移
- 从库不会丢失主库上的任何修改

缺点：

- 故障处理比较复杂
- 对执行的SQL有一定的限制



选择复制模式

- 所使用的MySQL版本
- 复制架构及主从切换的方式
- 所使用的高可用管理组件：MM（指支持日志点），MMHA（支持日志点和GTID）
- 对应用的支持程度



#### MySQL复制拓扑

![image-20200418143229024](D:\00_reference\mywiki\database\images\image-20200418143229024.png)



##### 一主多从的复制拓扑

![image-20200418143445697](D:\00_reference\mywiki\database\images\image-20200418143445697.png)

用途：

- 为不同业务使用不同的从库
- 将一台从库放到远程IDC，用作灾备恢复
- 分担主库的读负载



##### 主- 主复制拓扑

![image-20200418143845132](D:\00_reference\mywiki\database\images\image-20200418143845132.png)

- 主备模式的主主复制

  只有一台主服务器对外提供服务，一台服务器处于只读状态并且只作为热备使用。

  在对外提供服务的主库出现故障或者计划性的维护时才会进行切换。

  使原来的备库成为主库，而原来的主库会成为新的备库，并处理只读或是下线状态，待维护完成后重新上线。

  注意：

  - 确保两台服务器上的初始数据相同
  - 确保两台服务器上已经启动binlog并且有不同的server_id
  - 在两台服务器上启动log_slave_updates参数
  - 在初始的备库上启动read_only

  拥有备库的主-主复制拓扑

  ![image-20200418144912862](D:\00_reference\mywiki\database\images\image-20200418144912862.png)

- 主主模式的主主复制(不建议)

  容易产生数据冲突而造成复制链路的中断，耗费大量时间，造成数据丢失。

  注意：

  - 两个主中所操作的表最好能够分开
  - 使用下面两个参数控制自增ID的生成
    - auto_increment_increment = 2
    - auto_increment_offset = 1|2



##### 级联复制

避免主库因为复制而带来额外的负载。

![image-20200418145053077](D:\00_reference\mywiki\database\images\image-20200418145053077.png)



分发主库需启用：slave_log_update



#### MySQL复制性能优化

影响主从延迟的因素

![image-20200418145516373](D:\00_reference\mywiki\database\images\image-20200418145516373.png)



- 二进制日志传输时间（跨机房）

  使用MIXED日志格式，设置set binlog_row_image=minimal;

- 默认情况下从只有一个SQL线程，主上并发的修改在从上变成了串行

  一般会很快，串行避免了锁的争用。可以使用多线程复制（5.6版本以上）

  如何配置多线程复制：

  ```
  stop slave  // 停止链路复制
  set global slave_parallel_type = 'logical_clock'; // 决定了如何使用多线程复制，默认基于database，一个数据库一个线程
  set global slave_parallel_workers=4;
  start slave;
  
  show processlist
  ```





#### MySQL复制常见问题处理

由于数据损坏或丢失所引起的主从复制错误

- 主库或从库意外宕机引起的错误

  使用跳过二进制日志事件

  注入空事务的方式先恢复中断的复制链路

  再使用其他方法来对比主从服务器上的数据

- 主库的二进制日志损坏

  通过change master命令来重新指定

- 备库上的中继日志损坏

- 在从库上进行数据修改造成的主从复制错误

  设置read_only

- 不唯一的server_id或server_uuid。从服务器上的uuid也需要不同

  如果使用复制数据目录的方式初始化从库，这种情况下很容易发生。server_uuid是记录在数据目录的auto.cnf文件中。造成多个从服务器使用相同server_uuid。

- max_allow_packet设置（设置不同）引起的主从复制错误



主从复制无法解决问题：

- 无法分担主数据库的写负载

  分库分表解决写负载

- 无法自动进行故障转移及主从切换

- 无法提供读写分离功能



### 高可用架构

高可用性H.A.(High Availability)指的是尽量缩短因日常维护操作（计划）和突发的系统奔溃（非计划

所导致的停机时间，以提高系统和应用的可用性。

```
(365*24*60)*(1-0.99999)=5.256 (分钟)
结合业务和成本来选择
```



如何实现高可用

- 避免导致不可用的因素，减少系统不可用的时间。
  - 建立完善的监控及报警系统
  - 对备份数据进行恢复测试
  - 正确配置数据库环境
  - 对不需要的数据进行归档和清理
- 增加系统冗余，保证发生系统不可用时可以尽快恢复
  - 避免存在单点故障
  - 主从切换及故障转移



#### 单点故障

##### 解决方案介绍

![image-20200419091809476](D:\00_reference\mywiki\database\images\image-20200419091809476.png)

如何避免MySQL单点故障

![image-20200419091901822](D:\00_reference\mywiki\database\images\image-20200419091901822.png)

- 会导致共享存储变为单点，共享存储并不是一种好的解决单点故障的方式。

![image-20200419092113262](D:\00_reference\mywiki\database\images\image-20200419092113262.png)

- 故障转移所需时间比较长



![image-20200419092252858](D:\00_reference\mywiki\database\images\image-20200419092252858.png)

- 整个集群性能取决于性能最差的那台。写入性能差，只支持innodb



![image-20200419092450346](D:\00_reference\mywiki\database\images\image-20200419092450346.png)

- NDB很少被使用在生产环境中



**利用MySQL主从复制来解决MySQL单点故障**

- 如何解决主服务器的单点问题

  ![image-20200419092713400](D:\00_reference\mywiki\database\images\image-20200419092713400.png)

- 解决上述三个问题可以通过MMM、MHA解决。





#### MMM（Multi-Master Replication Manager）

MMM时管理MySQL主主复制（主备模式）的。

Perl开发

监控和管理MySQL的主主复制拓扑，并在当前的主服务器失效时，进行主和主备服务器之间的主从切换和故障转移等工作。

- MMM监控MySQL主从复制健康情况
- 对主库出现宕机时进行故障转移并自动配置其他从对新主的复制
  - 如何找到从库对应的新的主库日志点的日志同步点
  - 如果存在多个从库出现数据不一致的情况如何处理
- 提供了主，写虚拟IP，在主从服务器出现问题时可以自动迁移虚拟IP



MMM架构：

![image-20200419093838202](D:\00_reference\mywiki\database\images\image-20200419093838202.png)



MMM部署所需资源：

![image-20200419093921662](D:\00_reference\mywiki\database\images\image-20200419093921662.png)



##### MMM配置步骤

![image-20200419094624418](D:\00_reference\mywiki\database\images\image-20200419094624418.png)

1. 配置主主复制及主从同步集群

   ![image-20200419094718661](D:\00_reference\mywiki\database\images\image-20200419094718661.png)

   ![image-20200419094816104](D:\00_reference\mywiki\database\images\image-20200419094816104.png)

   

2. 安装主从节点所需要的支持包

   配置yum源：

   ![image-20200419095519944](D:\00_reference\mywiki\database\images\image-20200419095519944.png)

   ![image-20200419095550254](D:\00_reference\mywiki\database\images\image-20200419095550254.png)

   ![image-20200419095616676](D:\00_reference\mywiki\database\images\image-20200419095616676.png)

   ![image-20200419095727669](D:\00_reference\mywiki\database\images\image-20200419095727669.png)

3. 安装及配置MMM工具集

4. 运行MMM监控服务

5. 测试



##### MMM优缺点

优点：

- 使用Perl脚本语言开发及完全开源

- 提供了读写VIP（虚拟IP），使服务器角色的变更对前端应用透明

  在从服务器出现大量的主从延迟，主从链路中断时可以把这台从服务器上的读的虚拟IP，飘逸到集群中其他正常的服务器上。

- MMM提供了从服务器的延迟监控

- MMM提供了主数据库故障转移后从服务器对新主重新同步功能

- 很容易对发生故障的主数据库重新上线



缺点：

- 发布时间比较早不支持MySQL新的复制功能，六年前发布的新版本，存在一些小bug。
  - 基于gtid的复制可以保证日志不会重复在slave服务器上被执行。
  - 对于MySQL5.6后所提供的多线程复制技术也不支持
- 没有读负载均衡的功能。需要增加lvs，fs
- 进行主从切换时，容易造成数据丢失
- MMM监控服务存在单点故障



#### MHA（Master High Availability）

由Perl脚本开发

![image-20200419104307579](D:\00_reference\mywiki\database\images\image-20200419104307579.png)

- 保证数据的一致性
- 达到真正意义的高可用



MHA提供了什么功能

- 监控主数据服务器是否可用
- 当主DB不可用时，从多个从服务器中选举出新的主数据库服务器
- 提供了主从切换和故障转移功能



MHA是如何进行主从切换的

- 尝试从出现故障的主数据库保存二进制日志
- 从多个备选从服务器中选举出新的备选主服务器
- 在备选主服务器和其他从服务器之间同步差异二进制数据
- 应用从原主DB服务器上保存的二进制日志：重复的主键等会使MHA停止进行故障转移
- 提升备选主DB服务器为新的主DB服务器
- 迁移集群中的其他从DB作为新的主DB的从服务器



MHA演示架构

![image-20200419105130055](D:\00_reference\mywiki\database\images\image-20200419105130055.png)



![image-20200419105153863](D:\00_reference\mywiki\database\images\image-20200419105153863.png)





MHA配置步骤：

1. 配置集群内所有主机的SSH免认证登录

2. 安装MHA-node软件包和MHA-manager软件包

![image-20200419105331852](D:\00_reference\mywiki\database\images\image-20200419105331852.png)



3. 建立主从复制集群
4. 配置MHA管理节点
5. 使用masterha_check_ssh和masterha_check_repl对配置进行检验
6. 启动并测试MHA服务



![image-20200419105705280](D:\00_reference\mywiki\database\images\image-20200419105705280.png)



![image-20200419105803218](D:\00_reference\mywiki\database\images\image-20200419105803218.png)



![image-20200419110124114](D:\00_reference\mywiki\database\images\image-20200419110124114.png)



```
ssh免认证登录
ssh-keygen

```

![image-20200419110546666](D:\00_reference\mywiki\database\images\image-20200419110546666.png)



![image-20200419110849540](D:\00_reference\mywiki\database\images\image-20200419110849540.png)



![image-20200419111043081](D:\00_reference\mywiki\database\images\image-20200419111043081.png)



manager节点：

![image-20200419111215345](D:\00_reference\mywiki\database\images\image-20200419111215345.png)





##### MHA架构优缺点

优点：

- 同样是由Perl语言开发的开源工具
- 可以支持基于GTID的复制模式
- MHA再进行故障转移时更不易产生数据丢失
- 同一个监控节点可以监控多个集群



缺点：

- 需要编写脚本或者利用第三方工具来实现Vip的配置
- MHA启动后只会对主数据库进行监控
- 需要基于SSH免认证配置，存在一定的安全隐患
- 没由提供从服务器的读负载均衡功能





### 读写分离和负载均衡介绍

读写分离：

- 由程序实现读写分离

  优点：

  - 由开发人员控制什么样查询在从库中执行，因此比较灵活
  - 由程序直接连接数据库，所以性能损耗比较少

  缺点：

  - 增加了开发的工作量，使程序代码更加复杂
  - 人为控制，容易出现错误

- 由中间件实现读写分离

  工具：

  - mysql-proxy：一直处于实验产品

  - maxScale（推荐）

    MariaDB

  优点

  - 由中间件根据查询语法分析，自动完成读写分离
  - 对于程序透明，对于已有程序不用做任何调整

  缺点

  - 由于增加了中间层，所以对查询效率有损耗
  - 对于延迟敏感业务无法自动在主库执行



负载均衡

软件：

- LVS
- Haproxy
- MaxScale

硬件

- F5



### MaxScal实例演示



![image-20200420184020081](D:\00_reference\mywiki\database\images\image-20200420184020081.png)



![image-20200420184104806](D:\00_reference\mywiki\database\images\image-20200420184104806.png)





![image-20200420185535418](D:\00_reference\mywiki\database\images\image-20200420185535418.png)





## 数据库索引优化

MySQL支持的索引类型



B-tree索引的特点

- B-Tree索引以B+树的结构存储数据
- B-tree索引额能够加快数据的查询速度
- B-tree索引更适合进行范围查找

![image-20200421185107349](D:\00_reference\mywiki\database\images\image-20200421185107349.png)

什么情况下可以用到B树索引：

- 全值匹配的查询

  order_sn='9876233'

- 匹配最左前缀的查询

- 匹配列前缀查询

  order_sn like '9876%'

- 匹配范围值的查询

  order_sn > '98763243' and order_sn<'9876586778'

- 精确匹配左前列并范围匹配另外一列

- 只访问索引的查询

Btree索引的使用限制

![image-20200421190539710](D:\00_reference\mywiki\database\images\image-20200421190539710.png)



Hash索引的特点

Innodb自适应hash索引

![image-20200421190756974](D:\00_reference\mywiki\database\images\image-20200421190756974.png)



Hash索引的限制

![image-20200421191121018](D:\00_reference\mywiki\database\images\image-20200421191121018.png)

不适合用在数据类别少的列，比如性别。



为什么要使用索引：

![image-20200421191647085](D:\00_reference\mywiki\database\images\image-20200421191647085.png)



索引是不是越多越好

![image-20200421192059552](D:\00_reference\mywiki\database\images\image-20200421192059552.png)





![image-20200421192238921](D:\00_reference\mywiki\database\images\image-20200421192238921.png)





### 索引优化策略

![image-20200421192508323](D:\00_reference\mywiki\database\images\image-20200421192508323.png)





innodb：255，myisam：1000

![image-20200421194253704](D:\00_reference\mywiki\database\images\image-20200421194253704.png)







where多个条件，mysql5.0之前只能使用一个列索引，5.0之后mysql自动索引合并。

更好方式是使用联合索引

![image-20200421194726583](D:\00_reference\mywiki\database\images\image-20200421194726583.png)





![image-20200421195150572](D:\00_reference\mywiki\database\images\image-20200421195150572.png)

![image-20200421195424611](D:\00_reference\mywiki\database\images\image-20200421195424611.png)



























































## SQL查询优化





## 数据库分库分表





## 数据库监控









=======
# mysql 实战

[TOC]



## 影响数据库性能的因素

数据库需要**完整性**和**一致性**，相对不容易扩展。





![image-20191211092123224](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191211092123224.png)

![image-20191211092301249](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191211092301249.png)

![image-20191211092421262](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191211092421262.png)

（最好不要在主库上进行数据备份）





QPS ：每秒处理的查量

TPS：每秒事务数

1. 超高的QPS和TPS：80%的数据库问题都是慢查询导致。

2. 大量的并发和超高的cpu使用率

   - 大量的并发：数据库连接数倍占满（max_connections,默认100)
   - 超高的cpu使用率：因cpu自由耗尽而出现宕机。

3. 磁盘io，磁盘io性能突然下降。（大促前调整维护计划）

4. 网卡流量：网卡io被占满（1000Mb/8 相当于 100MB）

   - 减少从服务器的数量
   - 进行分级缓存
   - 避免使用“select *”进行查询
   - 分离业务网络和服务器网络

5. 其他

   - 大表带来的问题（数据量超过千万行，表数据文件巨大，超过10G）

     - 慢查询：很难在一定的时间内过滤出所需要的数据
     - 建立索引需要很长时间，mysql<5.5 会锁表，>5.5引起主从延迟。
     - 修改表结构需要长时间锁表
       - 造成长时间主从延迟
       - 影响正常的数据操作

     解决大表问题

     - 分库分表（很少这么做），难点：分表主键选择，分表后跨分区数据的查询和统计。
     - 大表的历史数据归档，减少对前后断业务的影响。难点：归档时间点的选择，如何进行归档操作

   - 大事务带来的问题

     事务时数据库系统区别于其他一切文件系统的重要特性之一

      

     事务是一组具有原子性的sql语句。原子性、一致性、隔离性（未提交读、已提交读、可重复读，可串行化（很少使用））、持久性。

     

     定义：一个事务必须被视为一个不可分割的最小工作单元，整个事物中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作。

     

     事务的隔离型：隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其他事务是不可见的。


![image-20190201234408042](./images/image-20190201234408042.png)

未提交读：可看到其他事务的修改。

已提交读：大部分默认隔离级别（除了Mysql），只能看到已提交事务的修改

可重复读：MySQL默认，在事务开始后，可重复读，不管其他事务是否已提交。

可串行化：会在读取的每一行数据上都加锁，基本不用。

```
show varibles like '%iso%';

set session tx_isolation='read-commited'
```



事务的持久性（durability）

定义：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。



大事务：运行时间比较长，操作的数据比较多的事务

风险

- 锁定太多的数据，造成大量的阻塞和锁超时
- 回滚时所需时间比较长
- 执行时间长，容易造成主从延迟

怎样处理大事务：

- 避免一次处理太多的数据
- 移除不必要在事务中的SELECT操作



目前mysql不支持多cpu并发运算。



## 什么影响了Mysql性能

![image-20191211092617802](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191211092617802.png)



那些因素影响数据库性能：

1. 硬件情况
2. 服务器操作系统，参数等
3. 数据库存储引擎
4. 数据库参数配置
5. 数据库结构设计和SQL语句



### 服务器硬件

#### CPU资源

是需要更好的cpu还是更多的cpu。

1. web项目适合更多的cpu，需要更高的并发量。
2. 使用多个cpu需要选择更好的mysql版本



MySQL不支持多CPU对同一SQL并发处理



**特别注意：**

- 不要在64位使用32位的服务器版本。（检查操作系统位数，使用32位操作系统对系统极大限制）
- 64位的CPU一定要工作在64位的系统下
- 对于并发比较高的场景CPU的数量比频率重要
- 对于CPU密集性场景和复杂SQL则频率越高越好





#### 内存大小

内存极大影响数据库性能。

- 内存并不是越多越好，当内存==磁盘，再增加没有意义
- 对性能影响有限度
- 并不能无限增加性能



根据数据库**热数据**选择内存



特别注意：

- 选择主板所能使用的最高频率的内存，内存频率越高，对性能越好。
- 内存大小对性能很重要，所以尽可能的大



#### 磁盘

##### 传统磁盘

选择因素：存储容量、传输速度、访问时间、主轴转速、物理尺寸

1. 传统磁盘，存储空间大，速度较慢。要选择转速快的。

2. raid技术，磁盘冗余队列的简称。简单来说Raid的作用就是把多个容量较小的磁盘组成一组容量更大的磁盘，并提供数据冗余来保证数据完整性的技术。

   主要的raid级别

   - raid 0 ： 组建磁盘整列最简单的形式，简单来说就是多个读磁盘组合在一起，没有提供冗余或错误修复能力。
   - raid 1：有成为**磁盘镜像**。磁盘利用率仅有50%，成本高。数据冗余性好，读性能较好。大部分操作系统都可以通过软件实现raid 0 和raid1.
   - raid 5 ：分布式**奇偶校验磁盘阵列**。整个整列只需要一块冗余。写很慢，随机读很快，适合以读为主的业务。最好使用在从数据库服务器上。
   - raid 10 ：又称为分片的镜像。读写性能好，重建会很简单。

   ![image-20190202161815719](./images/image-20190202161815719.png)

   raid级别选择：

   ![image-20190202161906635](./images/image-20190202161906635.png)

##### 固态存储

优缺点：

- 相比于机械磁盘，固态磁盘有更好的随机读写性能

- 相比机械磁盘，固态磁盘能更好的支持并发

- 相比机械磁盘，固态磁盘更容易损坏

ssd：使用sata接口，可以替代传统磁盘而不需要任何改动。sata接口的ssd同样支持raid技术。

pci-E ssd：无法使用sata接口，需要独特的驱动和配置。价格比ssd要贵，性能比ssd好。

使用场景

- 适用于存在大量随机i/o的场景，热数据大小远大于内存。
- 适用于解决单线程负载的i/o瓶颈，比如从服务器上（单线程，易损耗）。



##### 网络存储san和nas

是两种外部文件存储设备加载到服务器上的方法。

san设备通过**光纤**连接到服务器，设备通过块接口访问，服务器可以将其当作磁盘使用。

- 适合大量顺序读写，*随机读写慢*，不如本地raid磁盘。

nas设备使用**网络连接**，通过基于文件的协议如nfs或smb来访问，通过有网络传输的延迟。

适合场景：

- 网络存储不适合于mysql数据库存放数据，有人使用网络存储来实现高可用（牺牲性能）—牺牲性能，不易维护。
- 适合数据库备份



特别注意（I/O子系统）

- PCIe -》SSD（可以使用传统接口） -〉Raid10 -》磁盘 -〉SAN 





#### 网络性能限制

延迟 带宽

- 采用高性能和高带宽的网络接口设备和交换机
- 对多个网卡进行绑定，增强可用性和带宽
- 尽可能进行网络隔离



- 网络带宽对性能的影响

- 网络质量对性能的影响



建议：

- 采用高性能和高带宽的网络接口设备和交换机
- 对多个网卡进行绑定，增强可用性和带宽
- 尽可能的进行网络隔离







### 服务器系统

- windows：大小写不敏感，linux大小写敏感，可能在windows能跑，linux下不能跑。
- FreeBSD：老版本不行
- Solaris：稳定性著称
- Linux
- CentOs



在CentOS下哪些参数对Mysql性能有影响：

《Linux性能优化大师》

- 内核相关参数（/etc/sysctl.conf)

  - 网络相关：

    ```
    // 每个端口最大监听队列长度，负载大的一般会修改
    net.core.somaxconn=65535
    net.core.netdev_max_backlog=65535
    net.ipv4.tcp_max_syn_backlog=65535
    
    
    // tcp连接处理的等待状态的时间，用于加快tcp连接回收速度
    net.ipv4.tcp_fin_timeout=10
    net.ipv4.tcp_tw_reuse=1
    net.ipv4.tcp_tw_recycle=1
    
    
    // tcp 连接接收和发送缓冲区大小的默认值和最大值，对于数据库应用应该把这几个值调整的大一点
    net.core.wmem_default=87380
    net.core.wmem_max=16777216
    net.core.rmem_default=87380
    net.core.rmem_max=16777216
    
    
    // 用于减少失效连接所占用的tcp系统资源数量，加快资源回收效率,可以适当改小些
    net.ipv4.tcp_keepalive_time=120
    net.ipv4.tcp_keepalive_intvl=30
    net.ipv4.tcp_keepalive_probes=3
    
    ```

  - 内存相关

    ```
    // linux 内核参数中最重要的参数之一，用于定义单个共享内存段的最大值
    // 注意：
    // 1. 这个参数应该设置的足够大，以便能在一个共享内存段下荣大整个的Innodb缓冲池的大小。
    // 2. 这个值的大小对于64位linux系统，可取的最大值为物理内存值-1byte，建议值为大于物理内存的一半，一般取值大于Innodb缓着冲池即可，可以取物理内存-1byte
    kernel.shmmax=4294967295
    // 这个参数当内存不足时会对性能产生比较明显的影响
    // linux系统内存交换区：在linux系统安装时都会有一个特殊的磁盘分区，称之为系统交换分区，free -m可以查看到
    // 在MySQL服务器上是否使用交换分区有一些争议：在MySQL服务所在的Linux系统上完全禁用交换分区
    // 带来的风险：
    // 1. 降低操作系统的性能
    // 2. 容易造成内存溢出，崩溃，或都被操作系统kill掉
    // 结论：在MySQL服务器上保留交换区还是很必要的，但是要控制何时使用交换分区 
    // 就是告诉Linux内核除非虚拟内存完全满了，否则不要使用交换区
    vm.swappiness=0
    ```

  - 其他配置

    ![image-20191216225731879](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216225731879.png)

    ![image-20191216230005937](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230005937.png)

  - 磁盘性能相关

    ![image-20191216230156417](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230156417.png)

    cfq：完全公平队列，适合桌面系统，会在队列中插入不必要请求，响应时间慢

    ![image-20191216230524055](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230524055.png)

    ![image-20191216230549968](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230549968.png)

    ![image-20191216230615470](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230615470.png)

    修改方法：

    ![image-20191216230707999](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216230707999.png)

文件系统对性能的影响

![image-20191216231336470](/Users/zengxiangfei/Documents/mywiki/database/images/image-20191216231336470.png)





### MySQL体系结构

![image-20191221102058107](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221102058107.png)

客户端：jdbc，odbc，php等

MySQL服务层：实现与存储引擎无关的所有特性。

存储引擎层

注意：存储引擎是针对于表的而不是针对于库的（一个库中的不同表可以使用不同的存储引擎，不建议使用）



### 数据库存储引擎的选择

#### **插件式存储引擎**

MyISAM（5.58和之前版本）：不支持事务，表级锁

- MyISAM存储引擎表由MYD和MYI组成

  ![image-20191221102510682](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221102510682.png)

- 特性

  - 并发性与锁级别，使用的是表级锁，而不是行级锁，对读写混合并发性不好
  - 表损坏修复 ,`check table tablename`、`repair table tablename`
  - 支持的索引类型：fullText
  - MyISAM表支持数据压缩
  - 版本MySQL5.0时默认表大小为4G

- 使用场景

  - 非事务型应用
  - 只读类应用
  - 空间类应用：支持空间函数，gprs数据等。



#### InnoDB存储引擎：MySQL5.5及之后版本默认存储引擎，

- Innodb使用表空间进行，数据存储

  ![image-20191221105835345](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221105835345.png)

  ![image-20191221105936852](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221105936852.png)

  ![image-20191221110010389](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221110010389.png)

  ![image-20191221110049548](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221110049548.png)

  系统表空间和独立表空间要如何选择：

  比较

  - 系统表空间无法简单的收缩文件大小
  - 独立表空间可以通过optimize table命令收缩系统文件
  - 系统表空间会产生IO瓶颈
  - 独立表空间可以同时向多个文件刷新数据

  建议：

  - 对Innodb使用独立表空间

  ![image-20191221110657264](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191221110657264.png)

  系统表空间还存储了什么信息：

  - Innodb数据字典信息，通过b数进行数据管理
  - undo回滚段

#### Innodb存储引擎的特性

- Innodb是一种事务性存储引擎

- 完全支持事务的ACID特性

- Redo Log 和Undo Log

  ![image-20191222225151368](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191222225151368.png)

- Innodb支持行级锁

- 行级锁可以最大程度的支持并发

- 行级锁是由存储引擎层实现的

  什么是锁（数据库系统区别于文件系统的重要特性）：

  - 锁对主要作用是管理共享资源的并发访问
  - 锁用于实现事务的隔离性

  锁的类型

  - 共享锁（也称读锁）

  - 独占锁（也称写锁）

    ![image-20191222230057021](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20191222230057021.png)

  锁的粒度-锁的策略

  - 表级锁
  - 行级锁

  阻塞和死锁：

  - 什么是阻塞：在有些时刻，一个事务中的锁需要等待另一个锁的释放
  - 什么是死锁：是指两个或两个以上的事务在执行中相互占用了对方等待的资源而产生的一种异常。死锁系统会发现并自动处理，少量的死锁不影响系统的运行。

- Innodb状态检查

  `show engine innodb status`

  参考mysql官方手册。

- 适用场景

  - Innodb适合大多数OLTP应用



#### MySql常用存储引擎之CSV

文件系统存储特点

- 数据以文本方式存储在文件中
- .csv文件存储表内容
- .csm文件存储表的元数据如表状态和数据量
- .frm文件存储表结构信息
- 所有列必须都不能为NULL的
- 不支持索引，不支持大表，不适合在线处理
- 可以对数据文件直接编辑

适用场景

- 适合作为数据交换的中间表



#### Mysql常用存储引擎之Archive

文件系统存储特点

- 以zlib对表数据进行压缩，磁盘I/O更少
- 数据存在在ARZ为后缀的文件中，表结构存储在frm中。
- 只支持insert和select操作
- 只允许在自增ID列上加索引



适用场景

- 日志和数据采集类应用



#### MySQL常用存储引擎之Memory

文件系统存储引擎特点

- 也称HEAP存储引擎，所以数据保存在内存中
- 数据易失性，一旦mysql重启，表中数据会丢失，表结构会保留
- 只有一个frm文件

功能特点

- 支持HASH索引（等值查询快，无法进行范围查询）和BTree索引（范围查找快），默认为HASH索引。
- 所有字段都是固定长度varchar(10) = char(10)
- 不支持BLOG和TEXT等大字段
- Memory存储引擎适用表级锁
- 最大大小由max_heap_table_size参数决定，默认16M，修改后需要对表重建



容易混淆的概念：

- Memory存储引擎表
- 临时表
  - 系统临时表
    - 超过限制使用Mysam临时表
    - 未超限制使用Memory表
  - create temporary table 建立的临时表

使用场景

- 用于查找或者是映射表，例如邮编和地区的对应表（hash对于等值查找很高效）
- 用于保存数据分析中产生的中间表
- 用于换成周期性聚合数据的结果表

注意：Memory数据易丢失，所以要求数据可再生



#### MySQL常用存储引擎之Federated

特点

- 提供了访问远程MySQL服务器上表的方法
- 本地不存储数据，数据全部放到原创服务器上
- 本地需要保存表结构和原创服务器的连接信息（存在一个frm文件）

如何使用

- 很少使用，禁止，启用需要在启动时增加federated参数

   ```
  mysql://user_name[:password]@host_name[:port_num]/db_name/tbl_name
  show engines;
  在my.cnf中加入：
  federated=1
  重启mysql服务器
  ```

  ![image-20200203134159881](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200203134159881.png)

- 可以通过复制实现该特性

使用场景

偶尔的统计分析及手工查询。



#### 如何选择存储引擎

大部分情况下，选择innodb。除非万不得已，不要混合使用存储引擎。

参考条件

- 事务
- 备份 innodb支持免费在线热备方案 mysqldump不是在线热备方案
- 奔溃恢复
- 存储引擎的特有特性



#### MySQL服务器参数介绍

MySQL获取配置路径

- 命令行参数

  `mysqld_safe --datadir=/data/sql_data`

- 配置文件

  通过以下命令获取mysql读取配置文件的顺序。

  ![image-20200314084440957](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314084440957.png)

Mysql配置参数作用域：

- 全局参数(可能需要重新登录才能生效)

  - set global 参数名=参数值;
  - set @@global.参数名  :=参数值;

- 会话参数

  set [session] 参数名=参数值

  set @@session.参数名:=参数值;

mysql5.7之后有部分参数支持修改全局参数后不需要重新登录就可以生效。



### 数据库参数配置（重要）

#### 内存相关参数

- 确定可以使用的内存的上限，如果32位操作系统（Mysql单进程）就只能使用3G以内内存

- 确定Mysql的每个连接使用的内存

  sort_buffer_size：在查询需要排序时，会给所有连接分配该指定内存。分配时要小心，不宜过大。

  join_buffer_size：连接缓冲，当多表查询时会分配多个

  read_buffer_size:4K倍数 有查询需要时

  read_rnd_buffer_size

- 确定需要为操作系统保留多少内存

- 如何为缓存池分配内存

  - Innodb_buffer_pool_size ：缓存索引，数据等数据，延迟写入。必须保证足够的内存。

    总内存-（每个线程所需要的内存*连接数）-系统保留内存

    （MySQL手册建议的时服务器内存的75%）

  - key_buffer_size:主要用于myisam，myisam缓存池只缓存索引，数据依赖于操作系统的缓存。Mysql的系统表还在使用myisam存储引擎，所以还是需要给key_buffer_size分配一定的空间。【

    ![image-20200314103659184](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314103659184.png)

    

#### I/O相关配置参数

##### InnoDB I/O相关配置

- Innodb_log_file_size 控制了单个事务日志的大小 。跟业务情况相关，如果业务非常繁忙，设置大一些有好处。大小应为记录服务器一个小时左右的事务信息。

- Innodb_log_files_in_group 控制着事务日志文件的个数

- 事务日志的总大小=Innodb_log_file_size*Innodb_log_files_in_group

- Innodb_log_buffer_size :   能够保留1秒钟的事务就足够了。 32M～128M

- Innodb_flush_log_at_trx_commit : 刷新事务日志的频繁程度

  设置为2时mysql进程奔溃不会丢失数据，但是在整个服务器宕机可能会丢失1秒数据。

  ![image-20200314145337744](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314145337744.png)

![image-20200314145900954](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314145900954.png)



##### MyISAM I/O相关配置

- delay_key_write

  ![image-20200314150146672](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314150146672.png)



#### 安全相关配置

- expire_logs_days 指定自动清理binlog的天数

- max_allowed_packet 控制mysql可以接收包的大小 32M 主从复制，主从这个参数要保持一致。

- skip_name_resolve 禁用DNS查找

- sys date_is_now 确定sys date()返回确定性日期，和now()结果一致。 建议增加

- read_only 禁止非super权限的用户写权限 建议在从库中启用。在给用户授权时注意，不要给予super权限。

- skip_slave_start 禁用slave自动恢复 用在从库上，阻止mysql在重启后试图自动的启动复制。

- sql_mode 设置MySQL所使用的SQL模式

  ![image-20200314162522117](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314162522117.png)

#### 其他常用配置参数

- sync_binlog 控制MySQL如何向磁盘刷新binlog 默认为0，表示默认由操作系统控制 主从复制的主DB来说，建议设置为1，避免由于主DB奔溃而造成cache中的日志没有同步到二进制文件中。
- tmp_table_size 和 max_heap_table_size 控制内存临时表大小（memory存储引擎）
- max_connections 控制允许的最大连接数 默认值只有100，同城情况下会设置为2000或者稍微更大些。





### 数据库结构设计和SQL语句（影响最大）

数据库设计对性能的影响

- 过分的反范式化为表建立太多的列
- 过分的范式化造成太多的表关联（最多关联61个表），关联表应控制在10个以内
- OLTP环境中使用不恰当的分区表
- 使用外键保证数据的完整性（强烈建议不要使用外键约束）



性能优化顺序

- 数据库结构设计和SQL语句
- 数据库存储引擎的选择和参数配置
- 系统选择及优化
- 硬件升级



## MySQL基准测试

测量系统的性能 判断优化是否有效

基准测试：基准测试是一种测量和评估软件性能指标的活动用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新进行基准测试以评估变化对性能的影响。

基准测试是针对系统设置的一种压力测试。

基准测试：直接、简单、易于比较、用于评估服务器的处理能力。简化了的压力测试。

压力测试：对真实的业务数据进行测试，获得真实系统所承受的压力。



### 如何进行基准测试

基准测试的目的：

- 建立MySQL服务器的性能基准线，确定当前MySQL服务器运行情况。

- 模拟比当前系统更高的负载，以找出系统扩展瓶颈

  增加数据库并发、观察QPS、TPS变化，确定并发量与性能最优关系

- 测试不同的硬件、软件和操作系统配置

- 证明新的硬件设备是否配置正确。



对整个系统进行基准测试

从系统入口进行测试（如网站Web前端、手机App前端）

优点：

- 能够测试整个系统的性能，包括Web服务器缓存、数据库等。
- 能够反映出系统中各个组件接口间的性能问题体现真实性能状况。

缺点

- 测试设计复杂，消耗时间长



单独对MySQL进行基准测试

优点：

- 测试设计简单，所需耗费时间短

缺点：

- 无法全面了解整个系统的性能基线



指标

- 单位时间内所处理的事务数（TPS）

- 单位时间内所处理的查询数（QPS）

- 响应时间

  平均响应时间、最小响应时间、最大响应时间、各个时间所占百分比

- 并发量：同时处理的查询请求的数量（并发量并不等于连接数），指的是正在工作中的并发的操作数或同时工作的数量。



### 基准测试演示实例

计划和设计基准测试

- 对整个系统还是某一组件

- 使用什么样的数据

- 准备基准测试及数据收集脚本

  CPU使用率、IO、网络流量、状态与计数器信息 等

  Get_Test_info.sh 

  ![image-20200314174531475](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314174531475.png)



- 运行基准测试

- 保存和分析基准测试结果

  analyze.sh

  ![image-20200314183753638](/Users/zengxiangfei/Documents/mywiki/Database/images/image-20200314183753638.png)



基准测试容易忽略的问题：

- 使用生产环境数据时只使用了部分数据
- 在多用户场景中，只做单用户的测试 。推荐多线程并发测试。
- 在单服务器上测试分布式应用 **推荐：**使用相同的架构进行测试。
- 反复执行统一查询



### Mysql基准测试工具

ab，httploader，对系统进行整体测试。

MySQL基准测试工具之 mysqlslap，mysql服务器自带，无需安装。

特点：

- 可以模拟服务器负载，并输出相关统计信息。
- 可以指定也可以自动生成查询语句。



常用参数说明：

- `--auto-generate-sql`由系统自动生成SQL脚本进行测试
- `--auto-generate-sql-add-autoincrement`在生成的表中增加自增ID
- `--auto-generate-sql-load-type`指定测试中使用的查询类型 默认使用混合（读写删除查询更新）
- `--auto-generate-sql-write-number`指定初始化数据生成的数据量。
- `--concurrency`指定并发线程数量。
- `--engine`指定要测试表的存储引擎，可以用逗号分隔多个存储引擎。
- `--no-drop`指定不清理测试数据
- `--iterations`指定测试运行的次数。每次测试都会重新生成测试数据，指定了这个参数，就不能指定no-drop参数。
- `--number-of-queries`指定每一个线程执行的查询数量
- `--debug-info` 指定输出额外的内存及CPU统计信息
- `--number-int-cols`指定测试表中包含INT类型列的数量
- `--number-char-cols`指定测试表中包含的varchar类型的数量
- `--create-schema`指定了用于执行测试的数据库的名字
- `--query`用于指定自定义SQL的脚步
- `--only-print`并不允许测试脚本，而是把生成的脚本打印出来





## MySQL数据库结构优化





## MySQL高可用架构设计





## 数据库索引优化





## SQL查询优化





## 数据库分库分表





## 数据库监控









>>>>>>> 9185dad981ee69353cdc95d8f2351c1a4dd998ba
